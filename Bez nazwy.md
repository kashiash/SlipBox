

Chcę zacząć pracę nad **modelem**. Chcę zmienić nasze **schemat** z szablonu "item" na "DDT item". Tworzymy własny węzeł, encję z atrybutami, używając naszych nowych danych i **Swift UI views**. W tym celu musimy stworzyć nowe obiekty **Core Data**. Jak odczytywać obiekty z bazy danych, jak je aktualizować, jak manipulować danymi i jak je usuwać. Musimy więc przejść przez te cztery operacje.
Zacznijmy od przejrzenia tego, co już mamy. W pliku **slipbox project dot XE data model** mam jedną encję "item". Nie chcę z niej korzystać, więc jeśli naciśniesz Tab, a następnie Delete, zostanie ona usunięta. Muszę stworzyć nową.
Na dole mamy przycisk "add entity". Klikając dwukrotnie, zmieniam nazwę na "note". Wybrana jest ta encja. Mogę również dodać atrybuty, takie jak tytuł mojej notatki, a następnie muszę zdefiniować typ. Jeśli nie zdefiniujesz typu, otrzymasz błąd. Wybieram typ "string" dla tytułu. W bocznym panelu mamy więcej informacji. Mamy tutaj tytuł, więc możesz również nadać mu nazwę i typ "Optional". Jest to opcjonalne dla bazy danych. Możesz również ustawić wartość domyślną, ale na razie nie będziemy z tego korzystać. Dodam więcej atrybutów. Drugi to "creation date", typu "date". Oba atrybuty są opcjonalne. To spowoduje wiele problemów w projekcie, ponieważ ten "item" jest używany wszędzie. Muszę otworzyć ponownie boczny panel. Jeśli klikniesz na encję w bocznym panelu, wyświetli się nazwa encji nadrzędnej. Nie mam nic. To jest klasa Note. Encje w Core Data zawsze są klasami. Program Xcode generuje pliki dla nas, możesz to zmienić na "manual", ale to jest skomplikowane. Lepiej pozwolić Xcode zadbać o te rzeczy. Możemy spojrzeć na to, co generuje, jak tylko pozbyję się wszystkich problemów. Teraz mogę rozwiązać jeden problem. W pliku "persistent file" dla mojego podglądu kontenera dodajemy kilka domyślnych elementów do kontekstu. To jest pierwsza operacja CRUD, czyli jak tworzyć instancję obiektu koordynatora. Widzisz, jak tworzyć obiekt "item" i Core Data musi mieć kontekst, który mówi, że ten obiekt należy do tej bazy danych. To jest również bardzo przydatne, ponieważ można zapytać obiekt o jego zarządzany kontekst obiektu, a każdy z moich obiektów otrzymuje ten sam inicjalizator z kontekstem. Możesz uruchomić to, ponieważ czasami nie aktualizuje się poprawnie. Możesz również wyczyścić folder zbudowany, ponieważ zmieniłem zbyt wiele rzeczy. Teraz działa, nie ma skarg. To jest najprostszy sposób tworzenia nowego obiektu, używając inicjalizatora z kontekstem. Gdy już masz obiekt, możesz go modyfikować lub aktualizować jego właściwości. Na przykład, mogę tutaj ustawić tytuł lub datę utworzenia. Więc będę po prostu używać tego, co robiliśmy wcześniej. Większość czasu zaczynasz pisać, a potem ustawiasz te właściwości. Zamiast tego możesz ustawić wartości domyślne dla niektórych właściwości, na przykład dla tej daty. Jest bardziej interesujące tworzenie wygodnych inicjalizatorów. Ale gdzie powinienem umieścić mój wygodny inicjalizator? Nie stworzyłem klasy "notes" samodzielnie. Możesz sprawdzić, skacząc do definicji "note". To jest tutaj. Plik "node.co data class" został wygenerowany automatycznie i nie powinien być edytowany. Możesz sprawdzić ten plik, ale nie umieszczaj w nim kodu bezpośrednio, ponieważ nie jest zarządzany przez nas. To samo dotyczy daty utworzenia. Widzisz tutaj niektóre rzeczy, które zostały wygenerowane. Jest to dodane w rozszerzeniu "notes", ponieważ jest to klasa i można łatwo dodać do rozszerzenia. I mają oznaczony, że jest zarządzany, ponieważ jest częścią aktualizacji dla Core Data. Widzisz tutaj moje dwie właściwości i funkcję, którą również chcemy użyć, czyli "fetch request". To sposób odczytywania danych i interesujące jest to, że "note" jest identyfikowalne. Dodano kilka wygodnych funkcji. Ale jak widzisz, są to automatycznie generowane pliki. Nie chcę ich dotykać, ale chcę dodać coś do "note" w rozszerzeniu. Tworzę plik, który sam zarządzam, aby nie kolidował z innymi rzeczami. Tworzę nową grupę, ponieważ dotyczy to również innych modeli. To jest model, a tutaj tworzę plik Swift. To jest plik Swift, ponieważ to jest plik modelu. Nie ma to nic wspólnego z interfejsem użytkownika. Więc nie SwiftUI. Zaczynam od rozszerzenia "note". Importuję Core Data, ponieważ będziemy dużo z niego korzystać. Teraz mogę napisać wszystkie wygodne inicjalizatory. Dodaję rozszerzenie do "note" w rozszerzeniach. Możesz tutaj umieścić funkcje, ale możesz również deklarować właściwości, ponieważ moje właściwości są w stosie Core Data. Należą do pliku modelu XCD. Możesz umieścić w tym miejscu obliczeniowe właściwości. Na przykład, co również zrobimy w pewnym momencie, to wygodne obsługiwanie opcji. Ale na razie chcę zacząć od napisania własnego wygodnego inicjalizatora. Wygodnie, init, co chciałem zrobić, to tytuł jako string, ponieważ obiekty koordynatora są klasami. Musimy użyć inicjalizatora klasy, w którym musisz wywołać dedykowany inicjalizator tej klasy. To jest don't init, a to jest ten z kontekstem. To jest ten, którego właśnie użyłem, co oznacza, że tworzymy tutaj obiekt, więc musimy mieć instancję kontekstu obiektu. Teraz mogę tutaj wywołać to samo. I ponieważ jest to rozszerzenie, mogę ustawić wszystkie moje właściwości, takie jak tytuł, na ten tytuł, a datę utworzenia na nową datę. Teraz moja data utworzenia zawsze będzie ustawiona. Jeśli na przykład znajdziesz się w sytuacji, w której nie używasz tego wygodnego inicjalizatora, ale nadal chcesz ustawić datę utworzenia, jest jeszcze jeden trik. Przeładowanie "awake from insert", ponieważ jest to wywoływane za każdym razem. Ustawienie daty utworzenia ma sens. Więc nie musisz tego robić. Wszystkie właściwości, które muszą być ustawione zawsze, niezależnie od tego, jaki inicjalizator używasz, powinny znaleźć się w "awake from insert". To jest coś, co należy do obiektu klasy. Mamy więc naszą pierwszą wygodną rzecz w rozszerzeniu. W "persistent" mogę teraz to wykorzystać. Mogę użyć tego, nie używam tego, używam tytułu "notes", na przykład mogę użyć indeksu tutaj i kontekstu, jeśli chcesz zobaczyć różne daty utworzenia. Możesz zawsze później zmienić datę utworzenia. Zwłaszcza teraz, dla mojego podglądu, może chcę to zrobić. Możesz również wrócić do pierwotnego. Możesz również dodać funkcje do tworzenia domyślnych elementów. Może zrobimy to później w naszym rozszerzeniu. To był pierwszy krok, jak tworzyć encję, jak tworzyć obiekt koordynatora, i już widziałeś trochę, jak aktualizować rzeczy.



Teraz przejdźmy do sytuacji, w których korzystasz z naszych danych. W tym widoku 50i muszę przejść do widoku mojego widoku treści, co jużzaczyna generować dużo błędów, ponieważ za każdym razem, gdy jest tam element, będzie narzekać.
Najważniejsze tu jest to, o czym już mówiłem. Jak czytam? Jak
dostaję dostęp do moich danych w bazie danych? Swiftui daje nam przydatny wrapper dla fetch request. W przeciwnym razie, jeśli jesteś tak jak tradycyjnie, musisz poprosić kontekst widoku o pobranie czegoś. Powiedz wszystkie opisy sortowania, utwórz
kontroler wyników fetch, pobierz wszystkie aktualizacje z urządzenia. To jest dużo. To jest bardzo krótkie.
Teraz co muszę tutaj faktycznie zmienić? Przede wszystkim, typ, który pobieram, to nie jest element. To jest
węzeł. Co oznacza, że nazwa mojego portfela to notatki. Teraz tutaj, a sposób sortowania tego nie jest
sortowanie według ścieżki klucza, ale właśnie według notatek. Możesz również sortować według daty utworzenia.
Dobrze. Właśnie to oczyszczam. Teraz w mojej liście tutaj używam
notatek. dla każdego z moich węzłów pokazuję notatkę i datę utworzenia notatek przed każdym
wymaga, aby typ był identyfikowalny. To jest już domyślnie dodane dla wszystkich naszych obiektów. ID, które jest używane, to identyfikator obiektu.
Więc to jest notes. ID obiektu, który jest obiektem NS managed object ID. To może być przydatne.
Jeśli chcesz pobrać węzeł według ID. To jest trochę ograniczone. Więc wolę po prostu dodać kolejny identyfikator
bardzo wygodnie tutaj. Następnie narzeka, że mam tutaj dwie funkcje. Nie rozumie tego, ponieważ jedna jest dla
dodawania elementu. Już widziałeś? To było to, co robiliśmy przed dodaniem nowego obiektu. Więc po prostu to zamieniam na węzły.
Właściwie to nie jest nowa notatka. To jest notatka. nowa notatka z kontekstem widoku, który tutaj dostaję
dla mojego środowiska, ten kontekst. Widzisz tutaj, kiedy dodaję ten element. Bezpośrednio zapisują. Można bezpośrednio do pliku.
Kiedy tworzysz to. Ponieważ to upraszcza mój widok. Trochę za bardzo dla mojego gustu. W zasadzie moglibyśmy to po prostu przenieść.
Jeśli zawsze, jeśli jesteś pewien, że zawsze chcesz go zapisać podczas tworzenia, zawsze możesz dodać go do inicjalizatora uciążliwości.
Więc to jest kontekst. Bezpieczny, omówię to trochę później, niektóre strategie zapisywania. Dobrze, to jest sposób na dodanie
elementu. Właściwie zmienię nazwę tej funkcji na dodaj notatkę, co jest tutaj również. dodaj notatkę używaną dla
przycisku plus, to usunie ten tekst i również narzeka na to usunięcie. Jeśli chcesz
teraz możesz to zostawić, po prostu zmieniając to na węzły. I znowu przenoszę to wszystko.
Zapisywanie i również przenoszę animację. Nie potrzebujesz animacji. Pokażę ci. Muszę to oczyścić. To jest trochę
trudne do zrozumienia, co to robi. Pokażę ci prostszy inny przykład tego. Po prostu usuń jeden węzeł.
Następnie możesz usunąć ten przycisk edycji, ponieważ w przypadku iOS jest to tylko iOS, można użyć przeciągnięcia
do usunięcia. Dobrze. Teraz to jest dużo mniejsze, żeby tylko przetestować. Jeśli nadal gdzieś się zawieszam.
Dobrze, to jest ładne. Aby przetestować inne rzeczy, tworzę widok szczegółowy. Więc tutaj to jest widok nawigacyjny z listą.
Gdzie po prostu używa jednego tekstu jako szczegółu. Stwórzmy widok szczegółowy węzła, ponieważ możemy również usuwać i aktualizować tam. Bez szczegółów węzła, więc szczegóły notatki muszą
mieć notatkę. To jest notatka. nowa notatka z kontekstem Widoku, który tutaj dostaję
dla mojego środowiska, ten kontekst. Następnie możesz dodać tutaj return.
Wcześniej musieliśmy zwrócić jakiś widok. Zwróć notatkę, w zależności od tego, jak to robimy. Zawsze powinniśmy tak naprawdę
dodać tutaj. I kontekst w środowisku. Dobrze, zmieńmy tytuł na Szczegóły notatki na V
przyklej i może pokażę tytuł. Więc to jest tytuł, a tutaj pokazuję tytuł notatki. To jest opcjonalne. Więc jednym sposobem na obsłużenie tego jest powiedzenie, jeśli Let title mam coś tylko wtedy pokazuję ten tekst. Bez tytułu. Mój widok staje się tylko tym tytułem. Widzisz tutaj ten tytuł. Dobrze, po prostu zmieńmy czcionkę na tytuł i odstępy 20. Dobrze, mam coś w podglądzie, świetnie. Widzę tytuł, który dodałem tutaj. To jest inny sposób odczytywania tego, a ponieważ mam ten szczegół notatki, chcę go połączyć. Więc w moim widoku zawartości dla przycisków nawigacyjnych celu używam mojego widoku szczegółów notatki z tą notatką.
Dobrze. Teraz, gdy kliknę, przechodzę do tego szczegółu i tutaj widzisz faktycznie liczby, ponieważ mam to poprzednie, gdzie dodałem różne liczby, widziałeś, jak tworzyć widoki. Już wspomniałem tutaj, jak usuwać je. A kiedy jestem tutaj w moich danych, dodam przycisk usuwania. przycisk, usuń notatkę i spróbujmy trochę się postarać o styl, dodając tutaj różowy jako kolor czcionki, wszystko, co dotyczy tworzenia lub usuwania obiektów, musi odbywać się za pośrednictwem kontekstu widoku. Teraz mogę ponownie pobrać nowy kontekst ze środowiska.
podobnie jak tutaj w widoku zawartości, pytając menedżera środowiskowego o kontekst. Ale w tym przypadku tak naprawdę nie muszę tego robić.
ponieważ każdy obiekt kredytodawcy ma swój kontekst pliku. Należy on do bazy danych, należy do

[17:58] Ponieważ mam notatkę, każdy obiekt wierzyciela ma swój kontekst, plik. Należy on do bazy danych, należy do
Co można uzyskać za pomocą właściwości `nodes.don'tManage` kontekstu. Zwraca mi to opcjonalnie i jest zarządzane
kontekst obiektu. Być może nie należy do kontekstu. Dobrze, więc będę używać tego, to jest mój **lidContext**.
To ma sens, ponieważ w zasadzie, gdy usuwam i chcę to usunąć, chcę powiedzieć plikowi, że
baza danych nie należy do usuwania tego węzła. To jest bardzo przydatny trik tutaj, aby uzyskać kontekst.
Następnie kontekst ma funkcje. Do wykonywania określonych zadań, a jedną z nich, którą chcę użyć, jest tutaj. `deleteObject()`. Więc to
usunie ten obiekt, a obiektem, który chcę usunąć, jest **note**. Usunę też niektóre puste linie.
Więc to mieści się na jednej stronie. To jest opcjonalny kontekst. Jeśli nie mam kontekstu, to właściwie nie należy do bazy danych i wtedy naprawdę nie
wiem, co to oznacza praktycznie. Ponieważ tak naprawdę nie powinienem go widzieć. Więc zawsze powinien być częścią kontekstu.
Teraz przetestujmy, czy usuwanie obiektu jest takie proste, wracając do **ContentView**. Tutaj możesz wybrać jeden z tych elementów
naciśnij przycisk **Delete**. A potem zniknęło, może powinienem zapamiętać, jaki znacznik czasu, na przykład pierwszy, to było 55.
Usuń i faktycznie znika. To jest również mniej w **ContentView** dla implementacji domyślnej tutaj. To robi to samo
`context.delete()`. Wywołuje funkcję `delete()` kontekstu, aby usunąć wszystkie te węzły. Więc robi to samo
sam, gdy tu przesuniesz do usunięcia. Dlatego jest dość łatwo usuwać, gdy usuwam lub dodaję węzły.

Teraz sprawdźmy, czy usuwanie obiektu jest naprawdę takie proste. Wróćmy do widoku "Content View". Tutaj możesz wybrać jeden z tych elementów, nacisnąć przycisk "Usuń" i obiekt zniknie. To samo dotyczy przesunięcia palcem w celu usunięcia obiektu. Usuwanie jest zatem proste zarówno przy dodawaniu, jak i usuwaniu węzłów.

Widoki zawsze są poprawnie aktualizowane, co jest niesamowite. Dzieje się tak dzięki właściwości `FetchRequest`. Możemy zmieniać deskryptor sortowania, zawsze musząc zdefiniować klucz, według którego chcemy sortować. Możemy również użyć predykatu, na przykład, gdy chcemy filtrować notatki zawierające określone słowo kluczowe. Możemy ustawić predykat i animację. Obecnie lista animuje pojawianie się nowych elementów. Jeśli ustawimy animację na "None", elementy będą pojawiać się bez animacji. Wracając jednak do domyślnej animacji, zazwyczaj lepiej zostawić pewną animację.

Możemy również tworzyć bardziej wygodne rozwiązania, korzystając z innego inicjalizatora `FetchRequest`. W naszym rozszerzeniu możemy stworzyć funkcję, która tworzy ten obiekt. Tworzymy funkcję `fetch`, która zwraca obiekt `FetchRequest`. Musimy podać typ, dla którego chcemy utworzyć żądanie, na przykład "note". Tworzymy obiekt `FetchRequest` z podaną nazwą encji, w tym przypadku "note". Należy również zadeklarować typ. W tym przypadku jest to "note". Następnie możemy dostosować ten obiekt, w szczególności musimy ustawić deskryptor sortowania. Jeśli tego nie zrobimy i mamy kilka notatek o tym samym tytule, nie wiadomo, jak je posegregować. Możemy dodać drugorzędny deskryptor sortowania, który mówi, że jeśli notatki mają ten sam tytuł, to sortowane są według daty. Dlatego jest to tablica deskryptorów sortowania. Wracając do naszego przykładu w widoku "Content View", gdzie sortujemy po dacie utworzenia, jest to dokładnie to samo.

Jeśli chodzi o wygodę, możemy dodać predykat do naszego żądania. Predykaty mają określony format. Chciałbym pokazać specyficzny przypadek. Czasami chcemy użyć predykatu, który zawsze zwraca wszystkie obiekty, ale nadal chcemy go podać. Wtedy jest to predykat prawdziwy, czyli mówimy, że chcemy pobrać wszystkie notatki. Dlatego teraz mamy predykat, który mówi, że chcemy pobrać wszystkie notatki. Jest to wygodne rozwiązanie, ponieważ często chcemy pobrać wszystkie obiekty. Możemy również przekazać predykat jako argument. Domyślnie jest to predykat "wszystko".

Czasami trudno jest pisać długie ciągi znaków, zwłaszcza jeśli muszą być dokładnie przepisane. Czasami zapominamy, jak coś napisać lub popełniamy błąd, a Xcode nie zawsze dobrze informuje nas o błędach. Aby to ułatwić, możemy utworzyć rozszerzenie dla `NSPredicate`, gdzie zdefiniujemy predykat "wszystko". To nie pasuje do grupy modelu, dlatego tworzymy rozszerzenie `CoreDataHelper`. Pragnę trochę uporządkować kod i unikać mieszania widoków i logiki. Tworzę plik rozszerzenia Swift o nazwie `NSPredicate+Helper`, które jest rozszerzeniem dla `NSPredicate`. Możemy utworzyć statyczną właściwość `all`, która jest właściwością tego rozszerzenia. Następnie możemy przekazać ten predykat do naszej funkcji `fetch`. Dzięki temu domyślną wartością będzie pobranie wszystkich notatek, co może być przydatne w wielu przypadkach.

Jestem zwolennikiem tworzenia bardziej wygodnych rozwiązań, dlatego lubię tworzyć rozszerzenia, takie jak to, dla `NSPredicate`, gdzie można umieścić predykat "wszystko". To nie pasuje do grupy modelu, dlatego tworzę rozszerzenie `CoreDataHelper`. Na przykład, moje narzędzie do zarządzania `Persistent Store` powinno być tam umieszczone. Chcę zacząć organizować kod i unikać mieszania widoków i logiki. Tworzę plik rozszerzenia Swift o nazwie `NSPredicate+Helper`, które jest rozszerzeniem dla `NSPredicate`. Dlatego właśnie tworzę to rozszerzenie, aby umieścić tam ten predykat "wszystko". Nie chcę go umieszczać w grupie modelu, dlatego tworzę oddzielne miejsce dla narzędzi Core Data.

W ten sposób, w funkcji `fetch` w moim widoku "Content View", domyślną wartością będzie pobranie wszystkich notatek, co jest sytuacją, którą chcemy ustawić jako domyślną, gdy nie podamy innego predykatu.





Czasami nie jesteś gotowy, aby cokolwiek pobrać i najlepiej jest tego nie robić. Przeciwieństwo to "none", a wtedy to staje się fałszowe. Mam nadzieję, że napisałem to poprawnie. Teraz jesteśmy gotowi i możemy użyć tego dla wszystkich naszych innych encji. Zauważyłem wygodny sposób tworzenia zapytania o pobranie. Możemy go również użyć w widoku "Content View" jako alternatywy. Deklaruję to jako "fetch request". "Fetch request" wie, że ta funkcja jest w moich notatkach i właśnie tego potrzebuję, ponieważ chcę go wywołać w ten sposób. Musi to być również funkcja statyczna. Funkcja ta musi być statyczna, co oznacza, że tutaj nie mogę napisać "fetch" z predykatem "all". Wygląda to czytelnie: "fetch request note fetch". To zastępuje tę część, której nie mogę usunąć. Teraz jest trochę krótsze i łatwiejsze do zrozumienia. Teraz zobaczę wszystkie swoje notatki w tych notatkach. Nic się nie zmieniło, ponieważ wciąż pobieram wszystkie notatki i wciąż używam tego samego sortowania. Fajne jest to, że możemy również zmieniać sposób ustawiania tego "fetch request" w inicjalizatorze. Będzie to przydatne, gdy użytkownik będzie chciał filtrować i ustawiać deskryptory sortowania. Możemy więc rozszerzyć to. Osobiście bardzo mi się to podoba, ponieważ nie muszę robić wiele, a zawsze mam najnowsze dane. To świetne. Przykładem użycia jest tutaj tablica notatek. Inny przypadkiem, o którym nie rozmawialiśmy, jest aktualizacja czegoś. Tutaj, w mojej notatce, mogę usunąć jedną z tych notatek, ale chcę zmienić tytuł. Jak to zrobić? W moim widoku szczegółowym notatki chciałbym dodać przycisk "Zmień tytuł na pusty tytuł". W tej sytuacji chcę ustawić tytuł notatki na pusty ciąg znaków. Jeśli kliknę tutaj, nic się nie dzieje, nie widać żadnych zmian. Chcę ci udowodnić coś, więc wezmę pierwszy wpis. Klikam na "Zmień tytuł na pusty tytuł". To nie aktualizuje tytułu tutaj, wracam, wracam ponownie i tym razem mój tytuł faktycznie znika. Jednym z aspektów aktualizacji jest to, że faktycznie zmieniłem dane, ale nie zaktualizowałem widoku tutaj. Muszę zmienić sposób, w jaki korzystam z tej notatki w moim widoku SwiftUI, aby zawsze dostawał odpowiednie aktualizacje. Trochę zaskakujące jest to, że obiekt notatki lub inne encje mogą być obserwowane, więc mogę to zrobić tutaj, używając `@ObservedObject`. Teraz spróbuję ponownie "Zmień tytuł na pusty tytuł" i faktycznie się zmienia. Możesz to również wypróbować w widoku "Content View" i możesz również użyć tego w przypadku większości typów, gdy masz tytuł i chcesz go dodać do pola tekstowego. Tytuł i powiązanie idą do mojej notatki. Musisz postrzegać to jak normalny obiekt obserwowalny, który w tym przypadku powinien być ciągiem znaków. Jest to narzekane, ale istnieje kilka sposobów na naprawienie tego. Jeden z nich to dodanie opakowania powiązania tutaj. To jest powiązanie tekstowe. To jest powiązanie. Widzisz tutaj, ma get i set. Dla get używam tytułu notatki, a jeśli go nie ma, zwracam pusty. Nie muszę przechodzić przez żadne przejścia, więc mogę po prostu użyć nowej wartości i ustawić ją w mojej notatce. To staje się więc nową wartością, więc "dollar zero". Prawdopodobnie powinienem to napisać trochę bardziej czytelnie. Więc to jest get i set. Dobra, więc mamy własne get i set. A tutaj mogę użyć tego powiązania tekstowego. To jest edytor tekstu. Po prostu dodam pole tekstowe o stylu zaokrąglonego obramowania i może trochę odstępu wokół wszystkiego. Teraz, gdy edytuję swoją notatkę, aktualizuje się również w polu tekstowym, które właśnie utworzyłem. Aktualizacja działa, ponieważ wszystkie encje są zgodne z obserwowalnym obiektem, co ułatwia obserwowanie i poprawne aktualizowanie widoku. Jeśli chodzi o powiązania, ponieważ moje właściwości są opcjonalne, możesz napisać swoje własne powiązanie tekstowe. Nie jest to zawsze wygodne, a obsługa opcjonalnych wartości może być irytująca. Dlatego dodamy więcej wygody do tego rozszerzenia. Tutaj możemy tworzyć właściwości obliczeniowe dla naszego tytułu notatki, który jest ciągiem znaków. Jak widziałeś, użyłem get i set wcześniej. Możesz zdefiniować, skąd to pobierać i jak to ustawić. Więc ja to pobieram dla siebie. Jeśli go nie ma, zwracam pusty. To jest sposób na przeniesienie tego tekstu przez te powiązania do mojego widoku, gdzie mogę dodać dużo kodu i prawdopodobnie będę często korzystać z mojej notatki. Więc lepiej jest przenieść to z widoków. Ponieważ teraz dla mojego powiązania tekstowego mogę użyć mojego opcjonalnego tytułu notatki z dolarem jako powiązanie. Spróbuję ponownie i zobaczysz, że aktualizuje się poprawnie. Tworzenie, odczyt, usuwanie jest bardzo łatwe. Aktualizacja obiektów jest łatwa, ale zawsze musisz pamiętać o poprawnym obserwowaniu ich w widokach, aby uzyskać właściwe aktualizacje. Mam kilka małych sztuczek, które sprawiają, że to działa bardzo dobrze.