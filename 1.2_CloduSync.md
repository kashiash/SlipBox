

# Core Data + iCloud Sync



Teraz chcę porozmawiać o używaniu Core Data z synchronizacją iCloud. Muszę wprowadzić kilka dostosowań, głównie dotyczących możliwości. Chcę także pokazać Ci panel iCloud, gdzie znajdują się dane i jak działa ich przepływ. Porozmawiamy też trochę o problemach z synchronizacją iCloud. Jak zdobyć więcej informacji na ten temat? Ponieważ nie jest to łatwe do znalezienia. Tworzę osobne gałęzie dla tego projektu. Korzystam z SourceTree, ponieważ jest bezpłatne. Tworzę więc oddzielną gałąź o nazwie "sync" i przekierowuję się do niej. Jeśli chcesz wrócić do głównej gałęzi, wystarczy dwukrotnie kliknąć. Dodaję to także do mojego projektu, więc teraz mogę przełączać się między tymi dwoma gałęziami. Muszę być w gałęzi "sync", ponieważ dodaję wszystkie zmiany tutaj. Ułatwia to pracę, ponieważ w razie potrzeby można je połączyć z główną gałęzią, a wszystko jest zachowane oddzielnie i uporządkowane. Przechodzę do ustawień celu, gdzie muszę dodać kilka możliwości. Większość z tych możliwości działa tylko dla płatnych kont deweloperów. Jeśli nie masz takiego konta i próbujesz dodać iCloud, to nie pojawi się ono. Muszę więc teraz przełączyć się na płatne konto dewelopera. W tym przypadku mam większą liczbę możliwości i mogę dodać iCloud. Teraz, pod sekcją iCloud, włączam CloudKit i musisz dodać kontener. Kontener mówi, jaki serwer chcesz użyć, jest to odpowiednik serwera i kontenera.



Muszę teraz przełączyć się na płatne konto dewelopera. W tym przypadku mam znacznie więcej możliwości i mogę dodać iCloud. Teraz, pod sekcją iCloud, włączam CloudKit i musisz dodać kontener. Kontener mówi, jaki serwer chcesz użyć, jest to odpowiednik serwera i kontenera. Ponieważ już mam tutaj kilka, po prostu wybieram jeden z nich. Możesz także dodać nowy kontener i musi on mieć nazwę. Określa, jaki rodzaj kontenera chcesz utworzyć. Zazwyczaj kopiujesz identyfikator pakietu, ponieważ jest on unikalny i ma sens, żeby identyfikator aplikacji i identyfikator serwera były ze sobą powiązane. Kopiujesz to, wracasz tutaj i w sekcji iCloud naciskasz przycisk "plus", a następnie dodajesz ten kontener. Mam już tak wiele kontenerów, że nie muszę tutaj klikać przycisku "odśwież". Po pewnym czasie powinno to działać i kontener zostanie utworzony na serwerze CloudKit. Dlatego dodano tutaj przycisk "Konsola CloudKit". Teraz przechodzimy do konsoli i wybieramy bazę danych CloudKit. U góry możesz wybrać różne kontenery. Na początku nie masz tutaj nic. Jeśli klikniesz na "indeksy", zobaczysz tylko jeden rodzaj rekordu, którym są użytkownicy. Teraz uruchamiamy naszą aplikację. Po prawidłowej konfiguracji dla CloudKit powinniśmy zobaczyć, że nasza definicja schematu lub modelu zostanie również zsynchronizowana z CloudKit. Powinniśmy to zobaczyć. Wracamy, aby zakończyć wszystkie konfiguracje. Wraz z CloudKit dodano również powiadomienia push. Dzieje się tak, ponieważ CloudKit, gdy łączy się z Twoją bazą danych, musi przesyłać wszystkie aktualizacje z serwera do urządzenia.

Kiedy klikniesz tutaj na `Indices` (wskaźniki), zobaczysz tylko jeden typ rekordu, którym jest `użytkownicy`. Teraz uruchamiamy naszą aplikację. Musimy przeprowadzić odpowiednią konfigurację dla **CloudKit**. Powinniśmy zobaczyć, że nasza definicja schematu lub modelu zostaje propagowana do **CloudKit**, więc powinno się to tam odzwierciedlić. Wracając, kończymy wszystkie ustawienia. Razem z **CloudKit** dodane zostały również powiadomienia `push`. Dzieje się tak dlatego, że kiedy **CloudKit** łączy się z naszą bazą danych, musi przekazać wszystkie aktualizacje z serwera z powrotem do naszej aplikacji. Dlatego musimy mieć automatyczne tło, które będzie to robić w tle. Nie widzimy tego bezpośrednio; jest to kodowanie **CloudKit**. Muszę również komunikować się w tle, aby otrzymywać aktualizacje. Po synchronizacji muszę również dodać tryb pracy w tle. Teraz, dla tej sekcji, potrzebuję powiadomień zdalnych oraz przetwarzania w tle. Konkretnie dla systemu macOS, ponieważ ten cel dotyczy również macOS, muszę przejść do sekcji `Signing & Capabilities` (Podpisywanie i Możliwości) i zaznaczyć `Network incoming connections` (Przychodzące połączenia sieciowe). Domyślnie w systemie macOS nie jest dozwolone pobieranie ani przesyłanie danych do internetu, dlatego musimy to jasno zadeklarować. To wystarczy, aby to działało. 

​	Dodam jeszcze jeden klucz w pliku `Info.plist`, aby uniknąć problemów podczas wysyłania aplikacji do App Store. W pliku `Info.plist` muszę dodać kilka więcej kluczy. Jeden z nich to `NSUserActivityTypes`, który jest typu `Array`.  Muszę również mieć kilka wpisów, które są wolne. Rozwijam to miejsce i dodaję trzy elementy, które są typu `string`. To, co jest interesujące, to wartości, które tutaj wprowadzamy. Pierwsza to `com.apple.security.networked-on-server`, następna to `client` i `sendMessageIntent`. Dodane zostało również wprowadzenie dla wymaganych trybów pracy w tle, ale domyślnie są one dodawane, więc nie musisz ich również dodawać. Teraz wszystko jest w porządku z ustawieniami i możemy przejść do kontenera **CloudKit**.

Teraz musimy naprawdę mieć tutaj ten **CloudKit**, aby to działało. W inicjalizatorze, gdy to konfigurujemy, chcę dodać kilka rzeczy. Ponieważ powiedziałem, że musimy przesłać nasz schemat do **CloudKit**, muszę dodać niektóre opcje, aby to zrobić. W inicjalizatorze chcę dodać te opcje, ale nie wtedy, gdy jestem w pamięci. Kiedy jestem tutaj w pamięci, oznacza to, że jest to tymczasowe miejsce, które używam do poprzedniego zadania, na które nie zwracam uwagi. Dlatego mogę również użyć `else`. Nie chcę również tego robić, gdy jestem w trybie debug. Wtedy używam zmiennej `debug` i opcji. To jest opcje inicjalizacji schematu kontenera CloudKit. Wtedy mogę powiedzieć `container.initialCloudKitSchema(options: myOptions)`. To może generować błąd, więc muszę użyć `try`, a następnie skorzystać z bloku `do-catch`, aby uzyskać wszystkie informacje.

Chodzi mi tylko o przesłanie mojego schematu. Wtedy jestem wtedy, kiedy jestem sobą, gdy uruchamiam to i dlatego korzystam z trybu debug. Jeśli debugujesz, używam opcji. Jest to opcja inicjalizacji schematu kontenera **CloudKit**. Następnie mogę powiedzieć `container.initialCloudKitSchema(options: myOptions)`. To może generować błąd, więc muszę użyć `try`, a następnie skorzystać z bloku `do-catch`, aby uzyskać wszystkie informacje.

Bardzo ważne jest użycie `catch`, ponieważ czasami mogą wystąpić niespodziewane problemy. Nie łapię ich. Tutaj drukuję `cloudKitSchemaError` i błąd. Zapomniałem o zamknięciu znacznika `#end`. Jeśli chcesz to trochę ułatwić do odczytania, możesz również wyodrębnić to jako funkcję `setUpSchemaSync`. Przeniosę ten fragment tutaj.

Teraz, w trybie debug, mogę zobaczyć, że muszę przeprowadzić przesyłanie schematu. Skonfigurowałem wszystko dla mojego kontenera, wczytuję mój kontener i konfiguruję moje konteksty widoku w celu automatycznego scalania zmian z rodzica. Możesz również dodać inną politykę scalania. Używam `NSMergeByPropertyObjectTrumpMergePolicy`, więc to dotyczy zmian w pamięci lub w trybie `NSMergeByPropertyObjectTrumpMergePolicy`, który jest polityką bazową dla właściwości. Używam tylko pierwszej polityki.

Teraz, gdy to uruchamiam, powinienem móc uruchomić to z synchronizacją **iCloud**. Spróbujmy na **MacOS**. Właśnie wyczyściłem moje dane wcześniej. Teraz, jeśli tutaj dodam kilka wpisów, pierwszą rzeczą, którą zobaczysz, jest to, że jest to bardzo aktywne, ponieważ wszystko się odbywa.



z moją synchronizacją **iCloud**. Spróbujmy na **MacOS**. Właśnie wyczyściłem dane wcześniej. Teraz, jeśli tutaj dodam kilka wpisów, pierwszą rzeczą, którą zobaczysz, jest to, że jest to bardzo aktywne, ponieważ wszystko się dzieje.

I ostatnia wiadomość mówi, że nie ma już żądania do wykonania, ponieważ aktualizowano dane i wysyłano je. Możesz spróbować jeszcze raz. Tak, zawsze próbuje, zawsze komunikuje się z **CloudKit**. Dodajmy jeszcze jeden wpis. Widzisz, że tutaj mamy zmienione pola. Mamy tutaj nowy rekord. To jest dobre, ponieważ wydaje się, że zostało przesłane do góry.

Ponieważ chcę to zobaczyć w pełni, połączę się teraz. Muszę uruchomić to na dwóch urządzeniach, więc zobaczymy, czy wszystko się synchronizuje. Nie możesz używać symulatora, ponieważ to nie działa z **iCloud**. Muszę użyć... Będę używał iPada w jednej ręce i Maca w drugiej. Możesz również użyć telefonu. Czy wiesz, że nagrywam ekran swojego iPada? I mogę to uruchomić. Muszę to zainstalować tylko raz. Okej, teraz działa. I zajęło to kilka sekund, żeby zaktualizować wszystko, ale teraz także dostałem wszystkie wpisy dla mojego Maca. Zatrzymam to i uruchamiam na moim Macu. Teraz mogę otworzyć to ponownie na moim iPadzie. I widzisz, oba są tutaj. Na przykład na tym jest mój Mac mogę dodać jeden wpis. I pojawia się tutaj na moim iPadzie. Mogę też przesunąć w lewo, żeby usunąć i usunąć ten wpis produktu. Więc ten tutaj, a potem także na moim Macu zniknął. Widzisz, że jest opóźnienie jednej sekundy między tymi aktualizacjami, to dlatego, że wszystko musi zostać przesłane, musi to być przetworzone na serwerze i potem wrócić.

i pojawia się tutaj na moim iPadzie. Mogę również przesunąć w lewo, aby usunąć ten wpis produktu. Więc ten tutaj, a potem także na moim Macu zniknął. Widzisz, że jest opóźnienie jednej sekundy między tymi aktualizacjami, to dlatego, że wszystko musi zostać przesłane, musi to być przetworzone na serwerze, a potem wrócić na moje inne urządzenie, ale działa to dość szybko. Okej. Więc to działa, mam moją synchronizację tutaj. Jednym typowym błędem jest to, że twoje miejsce w **iCloud** jest pełne. Możesz zobaczyć tutaj, że przekroczyłeś dostępne dane. I jest tutaj błąd. Powinieneś również sprawdzić ustawienia systemowe dla **iCloud**, nigdy nie wiesz, gdzie to jest. Tutaj w **iCloud** możesz sprawdzić, ile miejsca masz. Ja mam jeszcze cztery gigabajty wolne, więc to wystarcza dla mojej aplikacji do działania. Jeśli już wykorzystałeś wszystkie pięć gigabajtów, które są dostępne za darmo, i myślisz o swojej własnej aplikacji, to również nie będzie działać, ponieważ nie ma danych na serwerze dla twojej aplikacji. Bądź tego świadomy. Następnie chcę sprawdzić **CloudKit Dashboard**. Tak więc to były te ustawienia tutaj, kiedy jesteś już w konsoli. To jest tutaj, tylko... Okej, wciąż mam tutaj błąd wczytywania. Nie wiem, po prostu mi to nie działa. Dziwne. Teraz, jeśli spojrzę tutaj w sekcję indeksu, zobaczysz, że mam element z nazwą jednostki dla **CloudKit**. To są nazywane pola koordynatora w **CloudKit**. To był atrybut. To są właściwości. Niektóre z nich są dodane dla nas, takie jak nazwa jednostki i kilka innych, które dodaliśmy we własnym schemacie, takie jak znacznik czasowy. Właściwie to były domyślne. Więc jeśli przejdę tutaj do schematu, mam tę jednostkę...

To jest nazwa jednostki. Dla **CloudKit** są one nazywane Fields Coordinator. To był atrybut. To po prostu właściwości. Niektóre z nich są dodane dla nas, takie jak nazwa jednostki, a niektóre inne, które dodaliśmy we własnym schemacie, takie jak znacznik czasowy. Właściwie, to były domyślne wartości. Więc jeśli przejdę tutaj do schematu, mam ten element jednostki z tym atrybutem znacznika czasowego o typie daty. Dokładnie to dodano tutaj. To jest znacznik czasowy. Dla każdego z tych atrybutów lub jednostek, widzisz również, że dla elementu dodano CD. To jest Core Data, to jest w zasadzie **CloudKit**, które mówi: "Dodajemy kolejny poziom abstrakcji". Więc **CloudKit** mówi, że to są jednostki, które mapujemy z **Core Data** do **CloudKit**. To są dane, które właśnie przesłałem. I mamy wiele instancji naszego kontenera lub serwera. Zazwyczaj mamy wersję developerską, taką jak ta, którą wybrałem tutaj, i wersję produkcyjną. To jest schemat przeznaczony do użytku produkcyjnego. Możesz dodawać i modyfikować, ale nie możesz usuwać typów rekordów w środowisku produkcyjnym. Musisz uważać, co dodajesz do schematu dla środowiska produkcyjnego, ponieważ nie możesz łatwo tego później zmienić. To jest znacznie bardziej ograniczone niż to, co można zrobić z **Core Data**. Zawsze możesz dodawać nowe atrybuty, to nie jest problem, ale zmienianie nazw, na przykład, nie sądzę, żeby to działało. I jest to prawdopodobnie zbyt ryzykowne. Jeśli teraz spojrzysz na środowisko produkcyjne, pod NDC Schema jest tutaj tylko sekcja dla użytkowników. To dlatego, że gdy chcę opracować mój schemat, po prostu chcę testować rzeczy. Dodaję kilka rekordów i może zmienię zdanie. Jeśli zmienisz zdanie i chcesz wrócić, jest tutaj inna sekcja mówiąca "Ustawiamy środowisko".

​	(15) To spowoduje zresetowanie wszystkich Twoich rekordów. To właśnie zrobiłem wcześniej. Jeśli to zrobisz, trwale usuniesz wszystkie informacje. Oznacza to usunięcie środowisk produkcyjnych, które mam teraz. Nie dotyczy to użytkowników. Jeśli więc zmienisz zdanie i chcesz po prostu pozbyć się wszystkiego i zacząć od nowa, tak naprawdę nie możesz. Kiedy zresetujesz swoje środowisko, zresetuje ono środowisko produkcyjne. Używa wersji środowiska produkcyjnego, więc zawsze możesz wrócić do oryginalnego, ponieważ nie możesz się cofnąć dalej niż do środowiska produkcyjnego. Gdy jesteś zadowolony z tego, co zrobiłeś ze swoim schematem w środowisku developerskim i chcesz go przenieść do środowiska produkcyjnego, musisz przejść tutaj pod "Wdrożenie zmian schematu". Tutaj zostanie ci powiedziane, co dokładnie zmieniłeś. Na przykład, utworzyłem tutaj znaczniki czasu. Niektóre z nich nie dodaliśmy, takie jak znacznik czasu utworzenia i znacznik czasu modyfikacji. To tylko dla **CloudKit**, aby obsługiwał rzeczy. Również indeksy. Jeśli jesteś zadowolony, możesz dotknąć tutaj przycisku "Wdroż". I wtedy przeniesie to. Nie chcę tego robić, ponieważ tak naprawdę nie chcę zachować moich elementów, ponieważ wkrótce je usuniemy. Dobrze, to jest krótka forma dla bazy danych, a następnie masz telemetrię. Tutaj nic nie ma. Muszę użyć innego środowiska produkcyjnego zeszłego roku, a następnie zobaczysz, ile tak naprawdę wystąpiło błędów, jeśli rozmiar żądania jest zbyt duży, jeśli przekroczyłeś pewne limity, na przykład. To jest telemetria.

 Następnie możesz przejść do dzienników. Na przykład przetestowaliśmy naszą aplikację na różnych urządzeniach. Jeśli masz tylko jedno urządzenie, możesz użyć tego tutaj w środowisku developerskim. To jest aplikacja. To jest środowisko, a następnie chcesz zobaczyć wszystkie dzienniki w ciągu ostatnich 30 sekund i ostatniej godziny. Oto moje aktualizacje. Użyłem. To jest mój iPad. A to jest mój Mac. Jeśli chcesz zobaczyć rzeczy na żywo, możesz wybrać historię. Na przykład ostatnią minutę, ostatnie siedem dni. Możesz także przejść na tryb na żywo i zacząć przesyłać teraz. Muszę po prostu dotknąć czegoś na moim iPadzie lub dodać coś. Mam nadzieję, że to coś robi. Dobrze, teraz to przyszło. Dobrze, musiałem to powiększyć. Oto informacja, że rekord został zmodyfikowany. A potem możesz dotknąć i zobaczyć więcej. To jest interesujące, abyś zobaczył, że jesteś naprawdę połączony. Dobrze. Zatrzymaj przesyłanie strumieniowe. Wszystkie te badania związane z tym, jak działa Twoja aplikacja, są ważne, ale ponieważ jesteśmy tutaj w środowisku developerskim, mam nadmiar dostępu. Ale co się dzieje, gdy jesteś użytkownikiem i chcesz wiedzieć, czy wszystko działa tak, jak powinno, albo czy przekroczono limit? Jeśli wykorzystasz wszystkie pięć gigabajtów, jak uzyskać tę informację? To jest nieco trudniejsze, a najlepsze, co znalazłem, to skorzystanie z centrum powiadomień dla zdarzeń **CloudKit**. W moim pliku stałym dodam to. Mają sprawdzić stan synchronizacji. Więc to jest w centrum powiadomień domyślnych, a tutaj używam wydawcy, ponieważ chcę, aby to było łatwiejsze, ponieważ ja

Więc jest to w centrum powiadomień. Domyślnie korzystam z wydawcy. Ponieważ chcę, to jest łatwiejsze, ponieważ lubię `Combine`, aby ciągle otrzymywać wszystkie te powiadomienia. A to jest nazwa `ns-person cloudkit container persistential`, pojemnik na powiadomienia o zmianach wydarzeń. To jest wydawca i mogę tu używać `sink`.

Do otrzymywania wszystkich powiadomień narzeka, ponieważ muszę właściwie skonfigurować tutaj moje przechowywanie subskrypcji. W subskrypcji. Muszę mieć właściwość subskrypcji i muszę zaimportować `Combine`. Również pracuję z `Cloudkit`. Więc także tu importuję `Cloudkit`.

Następnie muszę utworzyć `VAR subscriptions`. To jest trzeci typ `AnyCancellable`. Teraz mogę to przechowywać w moich subskrypcjach. Więc ten strumień danych jest utrzymany tak długo, jak długo kontroler trwałego jest żywy. I narzeka, że niezmienna sama w sobie. Więc jeśli mógłbyś, ponieważ to jest struktura. Więc mogę zrobić z tego funkcję mutującą. Ale myślę, że lepiej byłoby to mieć jako klasę. Lepiej działa z wzorcem Singleton.

Więc mamy powiadomienie i mogę sprawdzić informacje. i informacje użytkownika, ma problemy i jakiekolwiek. Klucz, więc pierwszy, którego szukam, nazywa się `persistent cloudkit container event notification user info`. Dobrze, po prostu wprowadzam to, nie musisz tego zapamiętywać, raz masz ten kod, możesz go oczywiście używać. Więc to jest pozycja `cloudkit container event notification user info key`. Więc to mi teraz nie daje wartości dla tego klucza, który jest typem `Any`. Nie lubię tego, muszę to rzutować, dlatego rzucam to na coś, co ma. 

Mogę faktycznie zrobić coś, co jest bardziej, co jest typem zdarzenia. Więc jest to `persistent Cloudkit container event`. Więc użyjmy wyrażenia `guard`. Ponieważ mam tutaj kilka opcjonalnych. Więc `guard let event`. Inaczej, po prostu wracam, bo nie wiem, jeśli nie mam tego klucza. Nie naprawdę wiem, co to jest. 

Teraz mamy zdarzenie do sprawdzenia. Na przykład ma typ błędu i datę. Na przykład mamy datę rozpoczęcia i zakończenia. Jeśli nie masz daty końca, to znaczy, że coś zdarzyło. Procesowanie tego zdarzenia. Coś właśnie się zaczęło. Jak przesyłanie nowej jednostki i nie nowe wprowadzenie do naszej bazy danych. Wi

ęc możemy po prostu powiedzieć. jeśli zdarzenia i data są nowe. Wtedy coś się zaczęło. Więc po prostu tu używam wyrażeń `Cloud Print`. zdarzenie start else Wiemy, że skończyło, więc teraz mogę użyć innych rzeczy, takich jak zdarzenia. Typ. To jest wyliczenie. Więc po prostu używam `switch`. I patrzymy na przypadki konfiguracji. 

Oznacza to, że cloudkit sink skończył konfigurować. Konfiguracja zakończona. To powinno zdarzyć się tylko raz, gdy uruchamiamy naszą aplikację. Następnie mamy import. import event export jest to z punktu widzenia naszej aplikacji wysyłanie nowych zdarzeń, danych X i właściwie co się dzieje, skończyliśmy eksport. Więc mogę to po prostu przemianować na zakończone. Aby było to trochę łatwiejsze na później, gdy widzę moje instrukcje drukowania. i zmuszają cię do użycia domyślnego, więc to jest cloudkit dodał nowy typ zdarzenia. Nie zamierzam zawiesić mojej aplikacji tylko dlatego, że kalkulator coś zmienił. 

Dobrze, możemy też spojrzeć na zdarzenie. Sukces to jest ciekawe, ponieważ jeśli się powiodło, wszystko jest chyba w porządku. Więc jeśli to zdarzenie miało miejsce, zakończenie konfiguracji było udane, powinieneś to zobaczyć tutaj. zakończone nie jest to sukces, co oznacza, że jeśli to nie sukces, chcemy wiedzieć więcej. I dlatego powinniśmy spojrzeć na błąd. Więc jeśli mam błąd, chcę wydrukować ten błąd zdarzenia. Jest to błąd typu. Więc to i chcę dostać więcej informacji jak kody błędów i do tego muszę rzutować jako `CK record CK` oznacza `cloudkit` `cloudkit` błąd. Więc jeśli mamy błąd jako `CK error`. Możemy wtedy. Wydrukuj ten błąd. tutaj ma zlokalizowany opis, który mogę używać do debugowania, ponieważ jest czytelny dla użytkownika. Najlepszą rzeczą jest jednak używanie tych kodów błędów. Jest to typ wyliczenia. na przykład. 

Więc przekroczyłeś limit, proszę zwolnić. trochę miejsca na iCloud to będzie coś, co możesz potem zrobić, to dla każdego z tych przypadków możesz stworzyć wiadomość dla swojego użytkownika, którą pokażesz. Jak przejść od mojego kontrolera trwałego do mojego UI? Możesz tutaj stworzyć właściwość, to dlatego, że to jest Swift UI. Muszę zrobić moje obserwowane obiekt a potem mogę użyć ad. 

Opublikowano warm sync error lub możesz zrobić wiadomość sync error. sync error. wiadomość to jest opcjonalny łańcuch. żadne więc tutaj, w tym przypadku, możesz powiedzieć. self -dot sync error message możesz pokazać. Możesz ustawić tę wiadomość. Dla wszystkich tych. Nie wiem, 30 przypadków. I ta własność może mieć nadmiar ustawień widoku dla twojego ubrania Cloud kit think a potem pokaż do użycia. Działa to całkiem nieźle, muszę dostać trochę informacji. Czasami nie aktualizuje się poprawnie. Ale tylko podpowiedź by pomogła. I tylko informowanie użytkownika, żeby sprawdził swoje przechowywanie iCloud. Robi wielką różnicę. 

Nie chcę dodawać wszystkich innych przypadków. Po prostu odkomentuję to. I zostawiamy to jedno wydarzenie Cloud kit. Nie. Stworzyłem tutaj moją funkcję sprawdzającą status. Ale nigdy jej faktycznie nie zadzwoniłem. Przez mój konstruktor, kiedy powiedziałem wszystko o moim pojemniku. Również dodałem tę funkcję, która sprawdza status rzeczy. Więc jeśli uruchomisz i dostaniesz dużo innych wiadomości, możesz filtrować, bo ja mogę teraz filtrować, bo zawsze używam `cloudkit event`. 

Czy wiesz, zobaczmy. więc masz tutaj, na przykład mamy Cloudkid event set up finished. Więc każde zdarzenie zaczyna się od startu, potem kończy i udaje się, potem coś importuje, więc zaczęło, skończyło się z sukcesem. Import z sukcesem eksport z sukcesem eksport sukcesu. To daje mi dość dużo informacji. Naprawdę nie wiem, jak celowo stworzyć tutaj błąd. Chyba, że wyłączę internet. 

Dobrze, spróbujmy. Więc mam tutaj Esky ckr domain error free. No cóż, może ta informacja nie jest taka dobra. Więc muszę dowiedzieć się, co to jest za darmo. Może to jest Is Arrow dot code? Niepowodzenie sieci. Tak, tutaj jest, sieć niedostępna. Więc daje mi poprawną informację o błędzie. To jest rodzaj błędu. Możesz po prostu powiedzieć użytkownikowi. Tak, nie otrzymujesz nowych danych, bo nie jesteś podłączony do internetu. To jest dobra informacja. 

Więc tak, na pewno sprawdź je. W przeciwnym razie naprawdę nie musisz robić dużo obsługi błędów dla core data i cloudkit, ponieważ praktycznie wszystko jest obsługiwane

 automatycznie, ale niektóre błędy są naprawdę dobre, jeśli są obsługiwane przez użytkownika. Możemy to naprawić.

